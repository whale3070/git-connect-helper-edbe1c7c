import {
  Bytes,
  Option,
  SubmittableResult,
  TypeDefInfo,
  TypeRegistry,
  map,
  packageInfo,
  packageInfo2,
  randomAsU8a,
  toPromiseMethod,
  toRxMethod,
  toV1
} from "./chunk-DSHHPLUW.js";
import {
  BN_HUNDRED,
  BN_ONE,
  BN_ZERO,
  assertReturn,
  bnToBn,
  compactAddLength,
  compactStripLength,
  detectPackage,
  import_bn,
  isBn,
  isFunction,
  isNumber,
  isObject,
  isRiscV,
  isString,
  isUndefined,
  isWasm,
  logger,
  objectSpread,
  stringCamelCase,
  stringify,
  u8aConcat,
  u8aToHex,
  u8aToU8a
} from "./chunk-6YXBROOK.js";
import "./chunk-6SGQSWNH.js";
import {
  __privateAdd,
  __privateGet,
  __publicField
} from "./chunk-WOOG5QLI.js";

// node_modules/@polkadot/api-contract/packageInfo.js
var packageInfo3 = { name: "@polkadot/api-contract", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "16.5.4" };

// node_modules/@polkadot/api-contract/packageDetect.js
detectPackage(packageInfo3, null, [packageInfo2, packageInfo]);

// node_modules/@polkadot/api-contract/Abi/toV1.js
function v0ToV1Names(all) {
  return all.map((e) => objectSpread({}, e, {
    name: Array.isArray(e.name) ? e.name : [e.name]
  }));
}
function v0ToV1(registry, v0) {
  if (!v0.metadataVersion.length) {
    throw new Error("Invalid format for V0 (detected) contract metadata");
  }
  return registry.createType("ContractMetadataV1", objectSpread({}, v0, {
    spec: objectSpread({}, v0.spec, {
      constructors: v0ToV1Names(v0.spec.constructors),
      messages: v0ToV1Names(v0.spec.messages)
    }),
    types: toV1(registry, v0.types)
  }));
}

// node_modules/@polkadot/api-contract/Abi/toV2.js
var ARG_TYPES = {
  ContractConstructorSpec: "ContractMessageParamSpecV2",
  ContractEventSpec: "ContractEventParamSpecV2",
  ContractMessageSpec: "ContractMessageParamSpecV2"
};
function v1ToV2Label(entry) {
  return objectSpread({}, entry, {
    label: Array.isArray(entry.name) ? entry.name.join("::") : entry.name
  });
}
function v1ToV2Labels(registry, outType, all) {
  return all.map((e) => registry.createType(`${outType}V2`, objectSpread(v1ToV2Label(e), {
    args: e.args.map((a) => registry.createType(ARG_TYPES[outType], v1ToV2Label(a)))
  })));
}
function v1ToV2(registry, v1) {
  return registry.createType("ContractMetadataV2", objectSpread({}, v1, {
    spec: objectSpread({}, v1.spec, {
      constructors: v1ToV2Labels(registry, "ContractConstructorSpec", v1.spec.constructors),
      events: v1ToV2Labels(registry, "ContractEventSpec", v1.spec.events),
      messages: v1ToV2Labels(registry, "ContractMessageSpec", v1.spec.messages)
    })
  }));
}

// node_modules/@polkadot/api-contract/Abi/toV3.js
function v2ToV3(registry, v2) {
  return registry.createType("ContractMetadataV3", objectSpread({}, v2, {
    spec: objectSpread({}, v2.spec, {
      constructors: v2.spec.constructors.map((c) => (
        // V3 introduces the payable flag on constructors, for <V3, it is always true
        registry.createType("ContractConstructorSpecV3", objectSpread({}, c, { payable: true }))
      ))
    })
  }));
}

// node_modules/@polkadot/api-contract/Abi/toV4.js
function v3ToV4(registry, v3) {
  return registry.createType("ContractMetadataV4", objectSpread({}, v3, {
    spec: objectSpread({}, v3.spec, {
      constructors: v3.spec.constructors.map((c) => registry.createType("ContractConstructorSpecV4", objectSpread({}, c))),
      messages: v3.spec.messages.map((m) => registry.createType("ContractMessageSpecV3", objectSpread({}, m)))
    }),
    version: registry.createType("Text", "4")
  }));
}

// node_modules/@polkadot/api-contract/Abi/toLatestCompatible.js
var enumVersions = ["V6", "V5", "V4", "V3", "V2", "V1"];
function createConverter(next, step) {
  return (registry, input) => next(registry, step(registry, input));
}
function v6ToLatestCompatible(_registry, v6) {
  return v6;
}
function v5ToLatestCompatible(_registry, v5) {
  return v5;
}
function v4ToLatestCompatible(_registry, v4) {
  return v4;
}
var v3ToLatestCompatible = createConverter(v4ToLatestCompatible, v3ToV4);
var v2ToLatestCompatible = createConverter(v3ToLatestCompatible, v2ToV3);
var v1ToLatestCompatible = createConverter(v2ToLatestCompatible, v1ToV2);
var v0ToLatestCompatible = createConverter(v1ToLatestCompatible, v0ToV1);
var convertVersions = [
  ["V6", v6ToLatestCompatible],
  ["V5", v5ToLatestCompatible],
  ["V4", v4ToLatestCompatible],
  ["V3", v3ToLatestCompatible],
  ["V2", v2ToLatestCompatible],
  ["V1", v1ToLatestCompatible],
  ["V0", v0ToLatestCompatible]
];

// node_modules/@polkadot/api-contract/Abi/index.js
var l = logger("Abi");
var PRIMITIVE_ALWAYS = ["AccountId", "AccountId20", "AccountIndex", "Address", "Balance"];
function findMessage(list, messageOrId) {
  const message = isNumber(messageOrId) ? list[messageOrId] : isString(messageOrId) ? list.find(({ identifier }) => [identifier, stringCamelCase(identifier)].includes(messageOrId.toString())) : messageOrId;
  return assertReturn(message, () => `Attempted to call an invalid contract interface, ${stringify(messageOrId)}`);
}
function getMetadata(registry, json) {
  const vx = enumVersions.find((v) => isObject(json[v]));
  const jsonVersion = json.version;
  if (!vx && jsonVersion && !enumVersions.find((v) => v === `V${jsonVersion}`)) {
    throw new Error(`Unable to handle version ${jsonVersion}`);
  }
  const metadata = registry.createType("ContractMetadata", vx ? { [vx]: json[vx] } : jsonVersion ? { [`V${jsonVersion}`]: json } : { V0: json });
  const converter = convertVersions.find(([v]) => metadata[`is${v}`]);
  if (!converter) {
    throw new Error(`Unable to convert ABI with version ${metadata.type} to a supported version`);
  }
  const upgradedMetadata = converter[1](registry, metadata[`as${converter[0]}`]);
  return upgradedMetadata;
}
function isRevive(json) {
  const source = json["source"];
  const version = json["version"];
  const hasContractBinary = typeof source === "object" && source !== null && "contract_binary" in source;
  const hasVersion = typeof version === "number" && version >= 6;
  return hasContractBinary || hasVersion;
}
function parseJson(json, chainProperties) {
  const registry = new TypeRegistry();
  const revive = isRevive(json);
  const typeName = revive ? "ContractReviveProjectInfo" : "ContractProjectInfo";
  const info = registry.createType(typeName, json);
  const metadata = getMetadata(registry, json);
  const lookup = registry.createType("PortableRegistry", { types: metadata.types }, true);
  registry.setLookup(lookup);
  if (chainProperties) {
    registry.setChainProperties(chainProperties);
  }
  lookup.types.forEach(({ id }) => lookup.getTypeDef(id));
  return [json, registry, metadata, info, revive];
}
function isTypeSpec(value) {
  return !!value && value instanceof Map && !isUndefined(value.type) && !isUndefined(value.displayName);
}
function isOption(value) {
  return !!value && value instanceof Option;
}
var _decodeEventV6, _decodeEventV5, _decodeEventV4, _createArgs, _createMessageParams, _createEventParams, _createEvent, _createEventV5, _createEventV4, _createMessage, _decodeArgs, _decodeMessage, _encodeMessageArgs;
var Abi = class {
  constructor(abiJson, chainProperties) {
    __publicField(this, "events");
    __publicField(this, "constructors");
    __publicField(this, "info");
    __publicField(this, "json");
    __publicField(this, "messages");
    __publicField(this, "metadata");
    __publicField(this, "registry");
    __publicField(this, "environment", /* @__PURE__ */ new Map());
    __publicField(this, "isRevive");
    __privateAdd(this, _decodeEventV6, (record) => {
      const topics = record.event.data[2];
      const signatureTopic = topics[0];
      const data = record.event.data[1];
      if (signatureTopic) {
        const event = this.events.find((e) => e.signatureTopic !== void 0 && e.signatureTopic !== null && e.signatureTopic === signatureTopic.toHex());
        if (event) {
          return event.fromU8a(data);
        }
      }
      const amountOfTopics = topics.length;
      const potentialEvents = this.events.filter((e) => {
        if (e.signatureTopic !== null && e.signatureTopic !== void 0) {
          return false;
        }
        const amountIndexed = e.args.filter((a) => a.indexed).length;
        if (amountIndexed !== amountOfTopics) {
          return false;
        }
        return true;
      });
      if (potentialEvents.length === 1) {
        return potentialEvents[0].fromU8a(data);
      }
      throw new Error("Unable to determine event");
    });
    __privateAdd(this, _decodeEventV5, (record) => {
      const signatureTopic = record.topics[0];
      const data = record.event.data[1];
      if (signatureTopic) {
        const event = this.events.find((e) => e.signatureTopic !== void 0 && e.signatureTopic !== null && e.signatureTopic === signatureTopic.toHex());
        if (event) {
          return event.fromU8a(data);
        }
      }
      const amountOfTopics = record.topics.length;
      const potentialEvents = this.events.filter((e) => {
        if (e.signatureTopic !== null && e.signatureTopic !== void 0) {
          return false;
        }
        const amountIndexed = e.args.filter((a) => a.indexed).length;
        if (amountIndexed !== amountOfTopics) {
          return false;
        }
        return true;
      });
      if (potentialEvents.length === 1) {
        return potentialEvents[0].fromU8a(data);
      }
      throw new Error("Unable to determine event");
    });
    __privateAdd(this, _decodeEventV4, (record) => {
      const data = record.event.data[1];
      const index = data[0];
      const event = this.events[index];
      if (!event) {
        throw new Error(`Unable to find event with index ${index}`);
      }
      return event.fromU8a(data.subarray(1));
    });
    __privateAdd(this, _createArgs, (args, spec) => {
      return args.map(({ label, type }, index) => {
        try {
          if (!isObject(type)) {
            throw new Error("Invalid type definition found");
          }
          const displayName = type.displayName.length ? type.displayName[type.displayName.length - 1].toString() : void 0;
          const camelName = stringCamelCase(label);
          if (displayName && PRIMITIVE_ALWAYS.includes(displayName)) {
            return {
              name: camelName,
              type: {
                info: TypeDefInfo.Plain,
                type: displayName
              }
            };
          }
          const typeDef = this.registry.lookup.getTypeDef(type.type);
          return {
            name: camelName,
            type: displayName && !typeDef.type.startsWith(displayName) ? { displayName, ...typeDef } : typeDef
          };
        } catch (error) {
          l.error(`Error expanding argument ${index} in ${stringify(spec)}`);
          throw error;
        }
      });
    });
    __privateAdd(this, _createMessageParams, (args, spec) => {
      return __privateGet(this, _createArgs).call(this, args, spec);
    });
    __privateAdd(this, _createEventParams, (args, spec) => {
      const params = __privateGet(this, _createArgs).call(this, args, spec);
      return params.map((p, index) => ({ ...p, indexed: args[index].indexed.toPrimitive() }));
    });
    __privateAdd(this, _createEvent, (index) => {
      switch (this.metadata.version.toString()) {
        case "4":
          return __privateGet(this, _createEventV4).call(this, this.metadata.spec.events[index], index);
        default:
          return __privateGet(this, _createEventV5).call(this, this.metadata.spec.events[index], index);
      }
    });
    __privateAdd(this, _createEventV5, (spec, index) => {
      const args = __privateGet(this, _createEventParams).call(this, spec.args, spec);
      const event = {
        args,
        docs: spec.docs.map((d) => d.toString()),
        fromU8a: (data) => ({
          args: __privateGet(this, _decodeArgs).call(this, args, data),
          event
        }),
        identifier: [spec.module_path, spec.label].join("::"),
        index,
        signatureTopic: spec.signature_topic.isSome ? spec.signature_topic.unwrap().toHex() : null
      };
      return event;
    });
    __privateAdd(this, _createEventV4, (spec, index) => {
      const args = __privateGet(this, _createEventParams).call(this, spec.args, spec);
      const event = {
        args,
        docs: spec.docs.map((d) => d.toString()),
        fromU8a: (data) => ({
          args: __privateGet(this, _decodeArgs).call(this, args, data),
          event
        }),
        identifier: spec.label.toString(),
        index
      };
      return event;
    });
    __privateAdd(this, _createMessage, (spec, index, add = {}) => {
      const args = __privateGet(this, _createMessageParams).call(this, spec.args, spec);
      const identifier = spec.label.toString();
      const message = {
        ...add,
        args,
        docs: spec.docs.map((d) => d.toString()),
        fromU8a: (data) => ({
          args: __privateGet(this, _decodeArgs).call(this, args, data),
          message
        }),
        identifier,
        index,
        isDefault: spec.default.isTrue,
        method: stringCamelCase(identifier),
        path: identifier.split("::").map((s) => stringCamelCase(s)),
        selector: spec.selector,
        toU8a: (params) => __privateGet(this, _encodeMessageArgs).call(this, spec, args, params)
      };
      return message;
    });
    __privateAdd(this, _decodeArgs, (args, data) => {
      let offset = 0;
      return args.map(({ type: { lookupName, type } }) => {
        const value = this.registry.createType(lookupName || type, data.subarray(offset));
        offset += value.encodedLength;
        return value;
      });
    });
    __privateAdd(this, _decodeMessage, (type, list, data) => {
      const [, trimmed] = compactStripLength(data);
      const selector = trimmed.subarray(0, 4);
      const message = list.find((m) => m.selector.eq(selector));
      if (!message) {
        throw new Error(`Unable to find ${type} with selector ${u8aToHex(selector)}`);
      }
      return message.fromU8a(trimmed.subarray(4));
    });
    __privateAdd(this, _encodeMessageArgs, ({ label, selector }, args, data) => {
      if (data.length !== args.length) {
        throw new Error(`Expected ${args.length} arguments to contract message '${label.toString()}', found ${data.length}`);
      }
      return compactAddLength(u8aConcat(this.registry.createType("ContractSelector", selector).toU8a(), ...args.map(({ type: { lookupName, type } }, index) => this.registry.createType(lookupName || type, data[index]).toU8a())));
    });
    [this.json, this.registry, this.metadata, this.info, this.isRevive] = parseJson(isString(abiJson) ? JSON.parse(abiJson) : abiJson, chainProperties);
    this.constructors = this.metadata.spec.constructors.map((spec, index) => __privateGet(this, _createMessage).call(this, spec, index, {
      isConstructor: true,
      isDefault: spec.default.isTrue,
      isPayable: spec.payable.isTrue,
      returnType: spec.returnType.isSome ? this.registry.lookup.getTypeDef(spec.returnType.unwrap().type) : null
    }));
    this.events = this.metadata.spec.events.map((_, index) => __privateGet(this, _createEvent).call(this, index));
    this.messages = this.metadata.spec.messages.map((spec, index) => __privateGet(this, _createMessage).call(this, spec, index, {
      isDefault: spec.default.isTrue,
      isMutating: spec.mutates.isTrue,
      isPayable: spec.payable.isTrue,
      returnType: spec.returnType.isSome ? this.registry.lookup.getTypeDef(spec.returnType.unwrap().type) : null
    }));
    for (const [key, opt] of this.metadata.spec.environment.entries()) {
      if (isOption(opt)) {
        if (opt.isSome) {
          const value = opt.unwrap();
          if (isBn(value)) {
            this.environment.set(key, value);
          } else if (isTypeSpec(value)) {
            this.environment.set(key, this.registry.lookup.getTypeDef(value.type));
          } else {
            throw new Error(`Invalid environment definition for ${key}:: Expected either Number or ContractTypeSpec`);
          }
        }
      } else {
        throw new Error(`Expected Option<*> definition for ${key} in ContractEnvironment`);
      }
    }
  }
  /**
   * Warning: Unstable API, bound to change
   */
  decodeEvent(record) {
    switch (this.metadata.version.toString()) {
      case "4":
        return __privateGet(this, _decodeEventV4).call(this, record);
      case "5":
        return __privateGet(this, _decodeEventV5).call(this, record);
      default:
        return __privateGet(this, _decodeEventV6).call(this, record);
    }
  }
  /**
   * Warning: Unstable API, bound to change
   */
  decodeConstructor(data) {
    return __privateGet(this, _decodeMessage).call(this, "message", this.constructors, data);
  }
  /**
   * Warning: Unstable API, bound to change
   */
  decodeMessage(data) {
    return __privateGet(this, _decodeMessage).call(this, "message", this.messages, data);
  }
  findConstructor(constructorOrId) {
    return findMessage(this.constructors, constructorOrId);
  }
  findMessage(messageOrId) {
    return findMessage(this.messages, messageOrId);
  }
};
_decodeEventV6 = new WeakMap();
_decodeEventV5 = new WeakMap();
_decodeEventV4 = new WeakMap();
_createArgs = new WeakMap();
_createMessageParams = new WeakMap();
_createEventParams = new WeakMap();
_createEvent = new WeakMap();
_createEventV5 = new WeakMap();
_createEventV4 = new WeakMap();
_createMessage = new WeakMap();
_decodeArgs = new WeakMap();
_decodeMessage = new WeakMap();
_encodeMessageArgs = new WeakMap();

// node_modules/@polkadot/api-contract/util.js
function applyOnEvent(result, types, fn, isRevive2) {
  if (result.isInBlock || result.isFinalized) {
    const section = isRevive2 ? "revive" : "contracts";
    const records = result.filterRecords(section, types);
    if (records.length) {
      return fn(records);
    }
  }
  return void 0;
}

// node_modules/@polkadot/api-contract/base/Base.js
var Base = class {
  constructor(api, abi, decorateMethod) {
    __publicField(this, "abi");
    __publicField(this, "api");
    __publicField(this, "_decorateMethod");
    __publicField(this, "_isWeightV1");
    __publicField(this, "_isRevive");
    if (!api || !api.isConnected || !api.tx) {
      throw new Error("Your API has not been initialized correctly and is not connected to a chain");
    }
    this.abi = abi instanceof Abi ? abi : new Abi(abi, api.registry.getChainProperties());
    this.api = api;
    this._decorateMethod = decorateMethod;
    this._isWeightV1 = !api.registry.createType("Weight").proofSize;
    this._isRevive = this.abi.isRevive;
    if (this._isRevive) {
      if (!api.tx.revive || !isFunction(api.tx.revive.instantiateWithCode) || api.tx.revive.instantiateWithCode.meta.args.length !== 6) {
        throw new Error("The runtime does not expose api.tx.revive.instantiateWithCode with storageDepositLimit");
      } else if (!api.call.reviveApi || !isFunction(api.call.reviveApi.call)) {
        throw new Error("Your runtime does not expose the api.call.reviveApi.call runtime interfaces");
      }
    } else {
      if (!api.tx.contracts || !isFunction(api.tx.contracts.instantiateWithCode) || api.tx.contracts.instantiateWithCode.meta.args.length !== 6) {
        throw new Error("The runtime does not expose api.tx.contracts.instantiateWithCode with storageDepositLimit");
      } else if (!api.call.contractsApi || !isFunction(api.call.contractsApi.call)) {
        throw new Error("Your runtime does not expose the api.call.contractsApi.call runtime interfaces");
      }
    }
  }
  get registry() {
    return this.api.registry;
  }
};

// node_modules/@polkadot/api-contract/base/util.js
var EMPTY_SALT = new Uint8Array();
function withMeta(meta, creator) {
  creator.meta = meta;
  return creator;
}
function createBluePrintTx(meta, fn) {
  return withMeta(meta, (options, ...params) => fn(options, params));
}
function encodeSalt(salt = randomAsU8a()) {
  return salt instanceof Bytes ? salt : (salt == null ? void 0 : salt.length) ? compactAddLength(u8aToU8a(salt)) : EMPTY_SALT;
}
function convertWeight(weight) {
  const [refTime, proofSize] = isWeightV2(weight) ? [weight.refTime.toBn(), weight.proofSize.toBn()] : [bnToBn(weight), void 0];
  return {
    v1Weight: refTime,
    v2Weight: { proofSize, refTime }
  };
}
function isWeightV2(weight) {
  return !!weight.proofSize;
}

// node_modules/@polkadot/api-contract/base/Contract.js
var MAX_CALL_GAS = new import_bn.default(5e12).isub(BN_ONE);
var l2 = logger("Contract");
function createQuery(meta, fn) {
  return withMeta(meta, (origin, options, ...params) => fn(origin, options, params));
}
function createTx(meta, fn) {
  return withMeta(meta, (options, ...params) => fn(options, params));
}
var ContractSubmittableResult = class extends SubmittableResult {
  constructor(result, contractEvents) {
    super(result);
    __publicField(this, "contractEvents");
    this.contractEvents = contractEvents;
  }
};
var _query, _tx, _getGas, _exec, _read;
var Contract = class extends Base {
  constructor(api, abi, address, decorateMethod) {
    super(api, abi, decorateMethod);
    /**
     * @description The on-chain address for this contract
     */
    __publicField(this, "address");
    __privateAdd(this, _query, {});
    __privateAdd(this, _tx, {});
    __privateAdd(this, _getGas, (_gasLimit, isCall = false) => {
      const weight = convertWeight(_gasLimit);
      if (weight.v1Weight.gt(BN_ZERO)) {
        return weight;
      }
      return convertWeight(isCall ? MAX_CALL_GAS : convertWeight(this.api.consts.system.blockWeights ? this.api.consts.system.blockWeights.maxBlock : this.api.consts.system["maximumBlockWeight"]).v1Weight.muln(64).div(BN_HUNDRED));
    });
    __privateAdd(this, _exec, (messageOrId, { gasLimit = BN_ZERO, storageDepositLimit = null, value = BN_ZERO }, params) => {
      const palletTx = this._isRevive ? this.api.tx.revive : this.api.tx.contracts;
      return palletTx.call(
        this.address,
        value,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore jiggle v1 weights, metadata points to latest
        this._isWeightV1 ? convertWeight(gasLimit).v1Weight : convertWeight(gasLimit).v2Weight,
        storageDepositLimit,
        this.abi.findMessage(messageOrId).toU8a(params)
      ).withResultTransform((result) => (
        // ContractEmitted is the current generation, ContractExecution is the previous generation
        new ContractSubmittableResult(result, applyOnEvent(result, ["ContractEmitted", "ContractExecution"], (records) => records.filter((record) => {
          try {
            const contractAddress = record.event.data[0];
            if (this.address.eq(contractAddress)) {
              return true;
            }
            l2.debug(`Skipping event from different contract ${contractAddress.toString()} (this contract: ${this.address.toString()})`);
            return false;
          } catch (error) {
            l2.warn(`Unable to extract contract address from event: ${error.message}`);
            return false;
          }
        }).map((record) => {
          try {
            return this.abi.decodeEvent(record);
          } catch (error) {
            l2.error(`Unable to decode contract event: ${error.message}`);
            return null;
          }
        }).filter((decoded) => !!decoded), this._isRevive))
      ));
    });
    __privateAdd(this, _read, (messageOrId, { gasLimit = BN_ZERO, storageDepositLimit = null, value = BN_ZERO }, params) => {
      const message = this.abi.findMessage(messageOrId);
      return {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        send: this._decorateMethod((origin) => (this._isRevive ? this.api.rx.call.reviveApi.call : this.api.rx.call.contractsApi.call)(
          origin,
          this.address,
          value,
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore jiggle v1 weights, metadata points to latest
          this._isWeightV1 ? __privateGet(this, _getGas).call(this, gasLimit, true).v1Weight : __privateGet(this, _getGas).call(this, gasLimit, true).v2Weight,
          storageDepositLimit,
          message.toU8a(params)
        ).pipe(map(({ debugMessage, gasConsumed, gasRequired, result, storageDeposit }) => ({
          debugMessage,
          gasConsumed,
          gasRequired: gasRequired && !convertWeight(gasRequired).v1Weight.isZero() ? gasRequired : gasConsumed,
          output: result.isOk && message.returnType ? this.abi.registry.createTypeUnsafe(message.returnType.lookupName || message.returnType.type, [result.asOk.data.toU8a(true)], { isPedantic: true }) : null,
          result,
          storageDeposit
        }))))
      };
    });
    this.address = this.registry.createType(this._isRevive ? "AccountId20" : "AccountId", address);
    this.abi.messages.forEach((m) => {
      if (isUndefined(__privateGet(this, _tx)[m.method])) {
        __privateGet(this, _tx)[m.method] = createTx(m, (o, p) => __privateGet(this, _exec).call(this, m, o, p));
      }
      if (isUndefined(__privateGet(this, _query)[m.method])) {
        __privateGet(this, _query)[m.method] = createQuery(m, (f, o, p) => __privateGet(this, _read).call(this, m, o, p).send(f));
      }
    });
  }
  get query() {
    return __privateGet(this, _query);
  }
  get tx() {
    return __privateGet(this, _tx);
  }
};
_query = new WeakMap();
_tx = new WeakMap();
_getGas = new WeakMap();
_exec = new WeakMap();
_read = new WeakMap();

// node_modules/@polkadot/api-contract/base/Blueprint.js
var BlueprintSubmittableResult = class extends SubmittableResult {
  constructor(result, contract) {
    super(result);
    __publicField(this, "contract");
    this.contract = contract;
  }
};
var _tx2, _deploy;
var Blueprint = class extends Base {
  constructor(api, abi, codeHash, decorateMethod) {
    super(api, abi, decorateMethod);
    /**
     * @description The on-chain code hash for this blueprint
     */
    __publicField(this, "codeHash");
    __privateAdd(this, _tx2, {});
    __privateAdd(this, _deploy, (constructorOrId, { gasLimit = BN_ZERO, salt, storageDepositLimit = null, value = BN_ZERO }, params) => {
      const palletTx = this._isRevive ? this.api.tx.revive : this.api.tx.contracts;
      return palletTx.instantiate(
        value,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore jiggle v1 weights, metadata points to latest
        this._isWeightV1 ? convertWeight(gasLimit).v1Weight : convertWeight(gasLimit).v2Weight,
        storageDepositLimit,
        this.codeHash,
        this.abi.findConstructor(constructorOrId).toU8a(params),
        encodeSalt(salt)
      ).withResultTransform((result) => new BlueprintSubmittableResult(result, applyOnEvent(result, ["Instantiated"], ([record]) => new Contract(this.api, this.abi, record.event.data[1], this._decorateMethod), this._isRevive)));
    });
    this.codeHash = this.registry.createType("Hash", codeHash);
    this.abi.constructors.forEach((c) => {
      if (isUndefined(__privateGet(this, _tx2)[c.method])) {
        __privateGet(this, _tx2)[c.method] = createBluePrintTx(c, (o, p) => __privateGet(this, _deploy).call(this, c, o, p));
      }
    });
  }
  get tx() {
    return __privateGet(this, _tx2);
  }
};
_tx2 = new WeakMap();
_deploy = new WeakMap();

// node_modules/@polkadot/api-contract/base/Code.js
var CodeSubmittableResult = class extends SubmittableResult {
  constructor(result, blueprint, contract) {
    super(result);
    __publicField(this, "blueprint");
    __publicField(this, "contract");
    this.blueprint = blueprint;
    this.contract = contract;
  }
};
function isValidCode(code) {
  return isWasm(code) || isRiscV(code);
}
var _tx3, _instantiate;
var Code = class extends Base {
  constructor(api, abi, wasm, decorateMethod) {
    super(api, abi, decorateMethod);
    __publicField(this, "code");
    __privateAdd(this, _tx3, {});
    __privateAdd(this, _instantiate, (constructorOrId, { gasLimit = BN_ZERO, salt, storageDepositLimit = null, value = BN_ZERO }, params) => {
      const palletTx = this._isRevive ? this.api.tx.revive : this.api.tx.contracts;
      if (this._isRevive) {
        return palletTx.instantiateWithCode(
          value,
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore jiggle v1 weights, metadata points to latest
          this._isWeightV1 ? convertWeight(gasLimit).v1Weight : convertWeight(gasLimit).v2Weight,
          storageDepositLimit,
          compactAddLength(this.code),
          this.abi.findConstructor(constructorOrId).toU8a(params),
          encodeSalt(salt)
        ).withResultTransform((result) => new CodeSubmittableResult(result, ...applyOnEvent(result, ["Instantiated"], (records) => records.reduce(([blueprint, contract], { event }) => this.api.events.revive["Instantiated"].is(event) ? [
          blueprint,
          new Contract(this.api, this.abi, event.data[1], this._decorateMethod)
        ] : [blueprint, contract], [void 0, void 0]), this._isRevive) || [void 0, void 0]));
      }
      return palletTx.instantiateWithCode(
        value,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore jiggle v1 weights, metadata points to latest
        this._isWeightV1 ? convertWeight(gasLimit).v1Weight : convertWeight(gasLimit).v2Weight,
        storageDepositLimit,
        compactAddLength(this.code),
        this.abi.findConstructor(constructorOrId).toU8a(params),
        encodeSalt(salt)
      ).withResultTransform((result) => new CodeSubmittableResult(result, ...applyOnEvent(result, ["CodeStored", "Instantiated"], (records) => records.reduce(([blueprint, contract], { event }) => this.api.events.contracts.Instantiated.is(event) ? [blueprint, new Contract(this.api, this.abi, event.data[1], this._decorateMethod)] : this.api.events.contracts.CodeStored.is(event) ? [new Blueprint(this.api, this.abi, event.data[0], this._decorateMethod), contract] : [blueprint, contract], [void 0, void 0]), this._isRevive) || [void 0, void 0]));
    });
    this.code = isValidCode(this.abi.info.source.wasm) ? this.abi.info.source.wasm : u8aToU8a(wasm);
    if (!isValidCode(this.code)) {
      throw new Error("Invalid code provided");
    }
    this.abi.constructors.forEach((c) => {
      if (isUndefined(__privateGet(this, _tx3)[c.method])) {
        __privateGet(this, _tx3)[c.method] = createBluePrintTx(c, (o, p) => __privateGet(this, _instantiate).call(this, c, o, p));
      }
    });
  }
  get tx() {
    return __privateGet(this, _tx3);
  }
};
_tx3 = new WeakMap();
_instantiate = new WeakMap();

// node_modules/@polkadot/api-contract/promise/index.js
var BlueprintPromise = class extends Blueprint {
  constructor(api, abi, codeHash) {
    super(api, abi, codeHash, toPromiseMethod);
  }
};
var CodePromise = class extends Code {
  constructor(api, abi, wasm) {
    super(api, abi, wasm, toPromiseMethod);
  }
};
var ContractPromise = class extends Contract {
  constructor(api, abi, address) {
    super(api, abi, address, toPromiseMethod);
  }
};

// node_modules/@polkadot/api-contract/rx/index.js
var BlueprintRx = class extends Blueprint {
  constructor(api, abi, codeHash) {
    super(api, abi, codeHash, toRxMethod);
  }
};
var CodeRx = class extends Code {
  constructor(api, abi, wasm) {
    super(api, abi, wasm, toRxMethod);
  }
};
var ContractRx = class extends Contract {
  constructor(api, abi, address) {
    super(api, abi, address, toRxMethod);
  }
};
export {
  Abi,
  BlueprintPromise,
  BlueprintRx,
  CodePromise,
  CodeRx,
  ContractPromise,
  ContractRx,
  packageInfo3 as packageInfo
};
//# sourceMappingURL=@polkadot_api-contract.js.map
