var Ue = (o) => {
  throw TypeError(o);
};
var Ve = (o, l, d) => l.has(o) || Ue("Cannot " + d);
var We = (o, l, d) => (Ve(o, l, "read from private field"), d ? d.call(o) : l.get(o)), He = (o, l, d) => l.has(o) ? Ue("Cannot add the same private member more than once") : l instanceof WeakSet ? l.add(o) : l.set(o, d), ke = (o, l, d, b) => (Ve(o, l, "write to private field"), b ? b.call(o, d) : l.set(o, d), d);
const Dt = [
  ["Aztec", "M"],
  ["Codabar", "L"],
  ["Code39", "L"],
  ["Code93", "L"],
  ["Code128", "L"],
  ["DataBar", "L"],
  ["DataBarExpanded", "L"],
  ["DataMatrix", "M"],
  ["EAN-8", "L"],
  ["EAN-13", "L"],
  ["ITF", "L"],
  ["MaxiCode", "M"],
  ["PDF417", "M"],
  ["QRCode", "M"],
  ["UPC-A", "L"],
  ["UPC-E", "L"],
  ["MicroQRCode", "M"],
  ["rMQRCode", "M"],
  ["DXFilmEdge", "L"],
  ["DataBarLimited", "L"]
], Mt = Dt.map(([o]) => o), Ma = Mt.filter(
  (o, l) => Dt[l][1] === "L"
), Aa = Mt.filter(
  (o, l) => Dt[l][1] === "M"
);
function qt(o) {
  switch (o) {
    case "Linear-Codes":
      return Ma.reduce((l, d) => l | qt(d), 0);
    case "Matrix-Codes":
      return Aa.reduce((l, d) => l | qt(d), 0);
    case "Any":
      return (1 << Dt.length) - 1;
    case "None":
      return 0;
    default:
      return 1 << Mt.indexOf(o);
  }
}
function Fa(o) {
  if (o === 0)
    return "None";
  const l = 31 - Math.clz32(o);
  return Mt[l];
}
function Ra(o) {
  return o.reduce((l, d) => l | qt(d), 0);
}
const La = [
  "LocalAverage",
  "GlobalHistogram",
  "FixedThreshold",
  "BoolCast"
];
function ja(o) {
  return La.indexOf(o);
}
const Ne = [
  "Unknown",
  "ASCII",
  "ISO8859_1",
  "ISO8859_2",
  "ISO8859_3",
  "ISO8859_4",
  "ISO8859_5",
  "ISO8859_6",
  "ISO8859_7",
  "ISO8859_8",
  "ISO8859_9",
  "ISO8859_10",
  "ISO8859_11",
  "ISO8859_13",
  "ISO8859_14",
  "ISO8859_15",
  "ISO8859_16",
  "Cp437",
  "Cp1250",
  "Cp1251",
  "Cp1252",
  "Cp1256",
  "Shift_JIS",
  "Big5",
  "GB2312",
  "GB18030",
  "EUC_JP",
  "EUC_KR",
  "UTF16BE",
  /**
   * UnicodeBig [[deprecated]]
   */
  "UTF16BE",
  "UTF8",
  "UTF16LE",
  "UTF32BE",
  "UTF32LE",
  "BINARY"
];
function Ba(o) {
  return o === "UnicodeBig" ? Ne.indexOf("UTF16BE") : Ne.indexOf(o);
}
const Ua = [
  "Text",
  "Binary",
  "Mixed",
  "GS1",
  "ISO15434",
  "UnknownECI"
];
function Va(o) {
  return Ua[o];
}
const Wa = ["Ignore", "Read", "Require"];
function Ha(o) {
  return Wa.indexOf(o);
}
const ka = ["Plain", "ECI", "HRI", "Hex", "Escaped"];
function Na(o) {
  return ka.indexOf(o);
}
const It = {
  formats: [],
  tryHarder: !0,
  tryRotate: !0,
  tryInvert: !0,
  tryDownscale: !0,
  tryDenoise: !1,
  binarizer: "LocalAverage",
  isPure: !1,
  downscaleFactor: 3,
  downscaleThreshold: 500,
  minLineCount: 2,
  maxNumberOfSymbols: 255,
  tryCode39ExtendedMode: !0,
  returnErrors: !1,
  eanAddOnSymbol: "Ignore",
  textMode: "HRI",
  characterSet: "Unknown"
};
function ze(o) {
  return {
    ...o,
    formats: Ra(o.formats),
    binarizer: ja(o.binarizer),
    eanAddOnSymbol: Ha(o.eanAddOnSymbol),
    textMode: Na(o.textMode),
    characterSet: Ba(o.characterSet)
  };
}
function za(o) {
  return {
    ...o,
    format: Fa(o.format),
    contentType: Va(o.contentType),
    eccLevel: o.ecLevel
  };
}
const yo = "2.2.4", vo = "fba4e9503fee4518ca2e89510baeea9bcc36dc8d", Ga = {
  locateFile: (o, l) => {
    const d = o.match(/_(.+?)\.wasm$/);
    return d ? `https://fastly.jsdelivr.net/npm/zxing-wasm@2.2.4/dist/${d[1]}/${o}` : l + o;
  }
}, St = /* @__PURE__ */ new WeakMap();
function Xa(o, l) {
  return Object.is(o, l) || Object.keys(o).length === Object.keys(l).length && Object.keys(o).every(
    (d) => Object.hasOwn(l, d) && o[d] === l[d]
  );
}
function Xe(o, {
  overrides: l,
  equalityFn: d = Xa,
  fireImmediately: b = !1
} = {}) {
  var f;
  const [I, D] = (f = St.get(o)) != null ? f : [Ga], M = l != null ? l : I;
  let _;
  if (b) {
    if (D && (_ = d(I, M)))
      return D;
    const A = o({
      ...M
    });
    return St.set(o, [M, A]), A;
  }
  (_ != null ? _ : d(I, M)) || St.set(o, [M]);
}
function qa(o) {
  St.delete(o);
}
async function Ya(o, l, d = It) {
  const b = {
    ...It,
    ...d
  }, f = await Xe(o, {
    fireImmediately: !0
  });
  let I, D;
  if ("width" in l && "height" in l && "data" in l) {
    const {
      data: _,
      data: { byteLength: A },
      width: U,
      height: G
    } = l;
    D = f._malloc(A), f.HEAPU8.set(_, D), I = f.readBarcodesFromPixmap(
      D,
      U,
      G,
      ze(b)
    );
  } else {
    let _, A;
    if ("buffer" in l)
      [_, A] = [l.byteLength, l];
    else if ("byteLength" in l)
      [_, A] = [l.byteLength, new Uint8Array(l)];
    else if ("size" in l)
      [_, A] = [l.size, new Uint8Array(await l.arrayBuffer())];
    else
      throw new TypeError("Invalid input type");
    D = f._malloc(_), f.HEAPU8.set(A, D), I = f.readBarcodesFromImage(
      D,
      _,
      ze(b)
    );
  }
  f._free(D);
  const M = [];
  for (let _ = 0; _ < I.size(); ++_)
    M.push(
      za(I.get(_))
    );
  return M;
}
({
  ...It,
  formats: [...It.formats]
});
async function Zt(o = {}) {
  var l, d, b, f = o, I = !!globalThis.window, D = typeof Bun < "u", M = !!globalThis.WorkerGlobalScope;
  !((d = globalThis.process) === null || d === void 0 || (d = d.versions) === null || d === void 0) && d.node && ((b = globalThis.process) === null || b === void 0 ? void 0 : b.type) != "renderer";
  var _ = "./this.program", A, U = "";
  function G(t) {
    return f.locateFile ? f.locateFile(t, U) : U + t;
  }
  var tt, X;
  if (I || M || D) {
    try {
      U = new URL(".", A).href;
    } catch {
    }
    M && (X = (t) => {
      var e = new XMLHttpRequest();
      return e.open("GET", t, !1), e.responseType = "arraybuffer", e.send(null), new Uint8Array(e.response);
    }), tt = async (t) => {
      var e = await fetch(t, {
        credentials: "same-origin"
      });
      if (e.ok)
        return e.arrayBuffer();
      throw new Error(e.status + " : " + e.url);
    };
  }
  var nt = console.log.bind(console), V = console.error.bind(console), q, ht = !1, Qt, Jt, Y, W, dt, at, ot, T, Kt, te, ee = !1;
  function re() {
    var t = Pt.buffer;
    Y = new Int8Array(t), dt = new Int16Array(t), f.HEAPU8 = W = new Uint8Array(t), at = new Uint16Array(t), ot = new Int32Array(t), T = new Uint32Array(t), Kt = new Float32Array(t), te = new Float64Array(t);
  }
  function ar() {
    if (f.preRun)
      for (typeof f.preRun == "function" && (f.preRun = [f.preRun]); f.preRun.length; )
        yr(f.preRun.shift());
    ne(oe);
  }
  function or() {
    ee = !0, lt.xa();
  }
  function ir() {
    if (f.postRun)
      for (typeof f.postRun == "function" && (f.postRun = [f.postRun]); f.postRun.length; )
        pr(f.postRun.shift());
    ne(ae);
  }
  function At(t) {
    var e, r;
    (e = f.onAbort) === null || e === void 0 || e.call(f, t), t = "Aborted(" + t + ")", V(t), ht = !0, t += ". Build with -sASSERTIONS for more info.";
    var n = new WebAssembly.RuntimeError(t);
    throw (r = Jt) === null || r === void 0 || r(n), n;
  }
  var pt;
  function sr() {
    return G("zxing_reader.wasm");
  }
  function ur(t) {
    if (t == pt && q)
      return new Uint8Array(q);
    if (X)
      return X(t);
    throw "both async and sync fetching of the wasm failed";
  }
  async function cr(t) {
    if (!q)
      try {
        var e = await tt(t);
        return new Uint8Array(e);
      } catch {
      }
    return ur(t);
  }
  async function lr(t, e) {
    try {
      var r = await cr(t), n = await WebAssembly.instantiate(r, e);
      return n;
    } catch (a) {
      V(`failed to asynchronously prepare wasm: ${a}`), At(a);
    }
  }
  async function fr(t, e, r) {
    if (!t && WebAssembly.instantiateStreaming)
      try {
        var n = fetch(e, {
          credentials: "same-origin"
        }), a = await WebAssembly.instantiateStreaming(n, r);
        return a;
      } catch (i) {
        V(`wasm streaming compile failed: ${i}`), V("falling back to ArrayBuffer instantiation");
      }
    return lr(e, r);
  }
  function hr() {
    var t = {
      a: qn
    };
    return t;
  }
  async function dr() {
    function t(i, s) {
      return lt = i.exports, Xn(lt), re(), lt;
    }
    function e(i) {
      return t(i.instance);
    }
    var r = hr();
    if (f.instantiateWasm)
      return new Promise((i, s) => {
        f.instantiateWasm(r, (u, c) => {
          i(t(u));
        });
      });
    pt != null || (pt = sr());
    var n = await fr(q, pt, r), a = e(n);
    return a;
  }
  var ne = (t) => {
    for (; t.length > 0; )
      t.shift()(f);
  }, ae = [], pr = (t) => ae.push(t), oe = [], yr = (t) => oe.push(t), m = (t) => _e(t), g = () => xe(), yt = [], vt = 0, vr = (t) => {
    var e = new Ft(t);
    return e.get_caught() || (e.set_caught(!0), vt--), e.set_rethrown(!1), yt.push(e), Ie(t), Pe(t);
  }, H = 0, mr = () => {
    v(0, 0);
    var t = yt.pop();
    Se(t.excPtr), H = 0;
  };
  class Ft {
    constructor(e) {
      this.excPtr = e, this.ptr = e - 24;
    }
    set_type(e) {
      T[this.ptr + 4 >> 2] = e;
    }
    get_type() {
      return T[this.ptr + 4 >> 2];
    }
    set_destructor(e) {
      T[this.ptr + 8 >> 2] = e;
    }
    get_destructor() {
      return T[this.ptr + 8 >> 2];
    }
    set_caught(e) {
      e = e ? 1 : 0, Y[this.ptr + 12] = e;
    }
    get_caught() {
      return Y[this.ptr + 12] != 0;
    }
    set_rethrown(e) {
      e = e ? 1 : 0, Y[this.ptr + 13] = e;
    }
    get_rethrown() {
      return Y[this.ptr + 13] != 0;
    }
    init(e, r) {
      this.set_adjusted_ptr(0), this.set_type(e), this.set_destructor(r);
    }
    set_adjusted_ptr(e) {
      T[this.ptr + 16 >> 2] = e;
    }
    get_adjusted_ptr() {
      return T[this.ptr + 16 >> 2];
    }
  }
  var mt = (t) => Oe(t), Rt = (t) => {
    var e = H;
    if (!e)
      return mt(0), 0;
    var r = new Ft(e);
    r.set_adjusted_ptr(e);
    var n = r.get_type();
    if (!n)
      return mt(0), e;
    for (var a of t) {
      if (a === 0 || a === n)
        break;
      var i = r.ptr + 16;
      if (De(a, n, i))
        return mt(a), e;
    }
    return mt(n), e;
  }, gr = () => Rt([]), wr = (t) => Rt([t]), br = (t, e) => Rt([t, e]), $r = () => {
    var t = yt.pop();
    t || At("no exception to throw");
    var e = t.excPtr;
    throw t.get_rethrown() || (yt.push(t), t.set_rethrown(!0), t.set_caught(!1), vt++), H = e, H;
  }, Cr = (t, e, r) => {
    var n = new Ft(t);
    throw n.init(e, r), H = t, vt++, H;
  }, Tr = () => vt, Er = (t) => {
    throw H || (H = t), H;
  }, Pr = () => At(""), gt = {}, Lt = (t) => {
    for (; t.length; ) {
      var e = t.pop(), r = t.pop();
      r(e);
    }
  };
  function it(t) {
    return this.fromWireType(T[t >> 2]);
  }
  var et = {}, Z = {}, wt = {}, Or = class extends Error {
    constructor(t) {
      super(t), this.name = "InternalError";
    }
  }, bt = (t) => {
    throw new Or(t);
  }, Q = (t, e, r) => {
    t.forEach((u) => wt[u] = e);
    function n(u) {
      var c = r(u);
      c.length !== t.length && bt("Mismatched type converter count");
      for (var h = 0; h < t.length; ++h)
        j(t[h], c[h]);
    }
    var a = new Array(e.length), i = [], s = 0;
    {
      const u = e;
      for (let c = 0; c < u.length; ++c) {
        const h = u[c];
        Z.hasOwnProperty(h) ? a[c] = Z[h] : (i.push(h), et.hasOwnProperty(h) || (et[h] = []), et[h].push(() => {
          a[c] = Z[h], ++s, s === i.length && n(a);
        }));
      }
    }
    i.length === 0 && n(a);
  }, _r = (t) => {
    var e = gt[t];
    delete gt[t];
    var r = e.rawConstructor, n = e.rawDestructor, a = e.fields, i = a.map((s) => s.getterReturnType).concat(a.map((s) => s.setterArgumentType));
    Q([t], i, (s) => {
      var u = {};
      {
        const c = a;
        for (let h = 0; h < c.length; ++h) {
          const p = c[h], y = s[h], C = p.getter, P = p.getterContext, S = s[h + a.length], x = p.setter, O = p.setterContext;
          u[p.fieldName] = {
            read: (E) => y.fromWireType(C(P, E)),
            write: (E, K) => {
              var R = [];
              x(O, E, S.toWireType(R, K)), Lt(R);
            },
            optional: y.optional
          };
        }
      }
      return [{
        name: e.name,
        fromWireType: (c) => {
          var h = {};
          for (var p in u)
            h[p] = u[p].read(c);
          return n(c), h;
        },
        toWireType: (c, h) => {
          for (var p in u)
            if (!(p in h) && !u[p].optional)
              throw new TypeError(`Missing field: "${p}"`);
          var y = r();
          for (p in u)
            u[p].write(y, h[p]);
          return c !== null && c.push(n, y), y;
        },
        readValueFromPointer: it,
        destructorFunction: n
      }];
    });
  }, xr = (t, e, r, n, a) => {
  }, F = (t) => {
    for (var e = ""; ; ) {
      var r = W[t++];
      if (!r) return e;
      e += String.fromCharCode(r);
    }
  }, st = class extends Error {
    constructor(t) {
      super(t), this.name = "BindingError";
    }
  }, $ = (t) => {
    throw new st(t);
  };
  function Sr(t, e) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var n = e.name;
    if (t || $(`type "${n}" must have a positive integer typeid pointer`), Z.hasOwnProperty(t)) {
      if (r.ignoreDuplicateRegistrations)
        return;
      $(`Cannot register type '${n}' twice`);
    }
    if (Z[t] = e, delete wt[t], et.hasOwnProperty(t)) {
      var a = et[t];
      delete et[t], a.forEach((i) => i());
    }
  }
  function j(t, e) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Sr(t, e, r);
  }
  var Ir = (t, e, r, n) => {
    e = F(e), j(t, {
      name: e,
      fromWireType: function(a) {
        return !!a;
      },
      toWireType: function(a, i) {
        return i ? r : n;
      },
      readValueFromPointer: function(a) {
        return this.fromWireType(W[a]);
      },
      destructorFunction: null
    });
  }, Dr = (t) => ({
    count: t.count,
    deleteScheduled: t.deleteScheduled,
    preservePointerOnDelete: t.preservePointerOnDelete,
    ptr: t.ptr,
    ptrType: t.ptrType,
    smartPtr: t.smartPtr,
    smartPtrType: t.smartPtrType
  }), jt = (t) => {
    function e(r) {
      return r.$$.ptrType.registeredClass.name;
    }
    $(e(t) + " instance already deleted");
  }, Bt = !1, ie = (t) => {
  }, Mr = (t) => {
    t.smartPtr ? t.smartPtrType.rawDestructor(t.smartPtr) : t.ptrType.registeredClass.rawDestructor(t.ptr);
  }, se = (t) => {
    t.count.value -= 1;
    var e = t.count.value === 0;
    e && Mr(t);
  }, ut = (t) => globalThis.FinalizationRegistry ? (Bt = new FinalizationRegistry((e) => {
    se(e.$$);
  }), ut = (e) => {
    var r = e.$$, n = !!r.smartPtr;
    if (n) {
      var a = {
        $$: r
      };
      Bt.register(e, a, e);
    }
    return e;
  }, ie = (e) => Bt.unregister(e), ut(t)) : (ut = (e) => e, t), Ar = () => {
    let t = $t.prototype;
    Object.assign(t, {
      isAliasOf(r) {
        if (!(this instanceof $t) || !(r instanceof $t))
          return !1;
        var n = this.$$.ptrType.registeredClass, a = this.$$.ptr;
        r.$$ = r.$$;
        for (var i = r.$$.ptrType.registeredClass, s = r.$$.ptr; n.baseClass; )
          a = n.upcast(a), n = n.baseClass;
        for (; i.baseClass; )
          s = i.upcast(s), i = i.baseClass;
        return n === i && a === s;
      },
      clone() {
        if (this.$$.ptr || jt(this), this.$$.preservePointerOnDelete)
          return this.$$.count.value += 1, this;
        var r = ut(Object.create(Object.getPrototypeOf(this), {
          $$: {
            value: Dr(this.$$)
          }
        }));
        return r.$$.count.value += 1, r.$$.deleteScheduled = !1, r;
      },
      delete() {
        this.$$.ptr || jt(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && $("Object already scheduled for deletion"), ie(this), se(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0);
      },
      isDeleted() {
        return !this.$$.ptr;
      },
      deleteLater() {
        return this.$$.ptr || jt(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && $("Object already scheduled for deletion"), this.$$.deleteScheduled = !0, this;
      }
    });
    const e = Symbol.dispose;
    e && (t[e] = t.delete);
  };
  function $t() {
  }
  var Ut = (t, e) => Object.defineProperty(e, "name", {
    value: t
  }), ue = {}, ce = (t, e, r) => {
    if (t[e].overloadTable === void 0) {
      var n = t[e];
      t[e] = function() {
        for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++)
          i[s] = arguments[s];
        return t[e].overloadTable.hasOwnProperty(i.length) || $(`Function '${r}' called with an invalid number of arguments (${i.length}) - expects one of (${t[e].overloadTable})!`), t[e].overloadTable[i.length].apply(this, i);
      }, t[e].overloadTable = [], t[e].overloadTable[n.argCount] = n;
    }
  }, le = (t, e, r) => {
    f.hasOwnProperty(t) ? ((r === void 0 || f[t].overloadTable !== void 0 && f[t].overloadTable[r] !== void 0) && $(`Cannot register public name '${t}' twice`), ce(f, t, t), f[t].overloadTable.hasOwnProperty(r) && $(`Cannot register multiple overloads of a function with the same number of arguments (${r})!`), f[t].overloadTable[r] = e) : (f[t] = e, f[t].argCount = r);
  }, Fr = 48, Rr = 57, Lr = (t) => {
    t = t.replace(/[^a-zA-Z0-9_]/g, "$");
    var e = t.charCodeAt(0);
    return e >= Fr && e <= Rr ? `_${t}` : t;
  };
  function jr(t, e, r, n, a, i, s, u) {
    this.name = t, this.constructor = e, this.instancePrototype = r, this.rawDestructor = n, this.baseClass = a, this.getActualType = i, this.upcast = s, this.downcast = u, this.pureVirtualFunctions = [];
  }
  var Vt = (t, e, r) => {
    for (; e !== r; )
      e.upcast || $(`Expected null or instance of ${r.name}, got an instance of ${e.name}`), t = e.upcast(t), e = e.baseClass;
    return t;
  }, Wt = (t) => {
    if (t === null)
      return "null";
    var e = typeof t;
    return e === "object" || e === "array" || e === "function" ? t.toString() : "" + t;
  };
  function Br(t, e) {
    if (e === null)
      return this.isReference && $(`null is not a valid ${this.name}`), 0;
    e.$$ || $(`Cannot pass "${Wt(e)}" as a ${this.name}`), e.$$.ptr || $(`Cannot pass deleted object as a pointer of type ${this.name}`);
    var r = e.$$.ptrType.registeredClass, n = Vt(e.$$.ptr, r, this.registeredClass);
    return n;
  }
  function Ur(t, e) {
    var r;
    if (e === null)
      return this.isReference && $(`null is not a valid ${this.name}`), this.isSmartPointer ? (r = this.rawConstructor(), t !== null && t.push(this.rawDestructor, r), r) : 0;
    (!e || !e.$$) && $(`Cannot pass "${Wt(e)}" as a ${this.name}`), e.$$.ptr || $(`Cannot pass deleted object as a pointer of type ${this.name}`), !this.isConst && e.$$.ptrType.isConst && $(`Cannot convert argument of type ${e.$$.smartPtrType ? e.$$.smartPtrType.name : e.$$.ptrType.name} to parameter type ${this.name}`);
    var n = e.$$.ptrType.registeredClass;
    if (r = Vt(e.$$.ptr, n, this.registeredClass), this.isSmartPointer)
      switch (e.$$.smartPtr === void 0 && $("Passing raw pointer to smart pointer is illegal"), this.sharingPolicy) {
        case 0:
          e.$$.smartPtrType === this ? r = e.$$.smartPtr : $(`Cannot convert argument of type ${e.$$.smartPtrType ? e.$$.smartPtrType.name : e.$$.ptrType.name} to parameter type ${this.name}`);
          break;
        case 1:
          r = e.$$.smartPtr;
          break;
        case 2:
          if (e.$$.smartPtrType === this)
            r = e.$$.smartPtr;
          else {
            var a = e.clone();
            r = this.rawShare(r, B.toHandle(() => a.delete())), t !== null && t.push(this.rawDestructor, r);
          }
          break;
        default:
          $("Unsupporting sharing policy");
      }
    return r;
  }
  function Vr(t, e) {
    if (e === null)
      return this.isReference && $(`null is not a valid ${this.name}`), 0;
    e.$$ || $(`Cannot pass "${Wt(e)}" as a ${this.name}`), e.$$.ptr || $(`Cannot pass deleted object as a pointer of type ${this.name}`), e.$$.ptrType.isConst && $(`Cannot convert argument of type ${e.$$.ptrType.name} to parameter type ${this.name}`);
    var r = e.$$.ptrType.registeredClass, n = Vt(e.$$.ptr, r, this.registeredClass);
    return n;
  }
  var fe = (t, e, r) => {
    if (e === r)
      return t;
    if (r.baseClass === void 0)
      return null;
    var n = fe(t, e, r.baseClass);
    return n === null ? null : r.downcast(n);
  }, Wr = {}, Hr = (t, e) => {
    for (e === void 0 && $("ptr should not be undefined"); t.baseClass; )
      e = t.upcast(e), t = t.baseClass;
    return e;
  }, kr = (t, e) => (e = Hr(t, e), Wr[e]), Ct = (t, e) => {
    (!e.ptrType || !e.ptr) && bt("makeClassHandle requires ptr and ptrType");
    var r = !!e.smartPtrType, n = !!e.smartPtr;
    return r !== n && bt("Both smartPtrType and smartPtr must be specified"), e.count = {
      value: 1
    }, ut(Object.create(t, {
      $$: {
        value: e,
        writable: !0
      }
    }));
  };
  function Nr(t) {
    var e = this.getPointee(t);
    if (!e)
      return this.destructor(t), null;
    var r = kr(this.registeredClass, e);
    if (r !== void 0) {
      if (r.$$.count.value === 0)
        return r.$$.ptr = e, r.$$.smartPtr = t, r.clone();
      var n = r.clone();
      return this.destructor(t), n;
    }
    function a() {
      return this.isSmartPointer ? Ct(this.registeredClass.instancePrototype, {
        ptrType: this.pointeeType,
        ptr: e,
        smartPtrType: this,
        smartPtr: t
      }) : Ct(this.registeredClass.instancePrototype, {
        ptrType: this,
        ptr: t
      });
    }
    var i = this.registeredClass.getActualType(e), s = ue[i];
    if (!s)
      return a.call(this);
    var u;
    this.isConst ? u = s.constPointerType : u = s.pointerType;
    var c = fe(e, this.registeredClass, u.registeredClass);
    return c === null ? a.call(this) : this.isSmartPointer ? Ct(u.registeredClass.instancePrototype, {
      ptrType: u,
      ptr: c,
      smartPtrType: this,
      smartPtr: t
    }) : Ct(u.registeredClass.instancePrototype, {
      ptrType: u,
      ptr: c
    });
  }
  var zr = () => {
    Object.assign(Tt.prototype, {
      getPointee(t) {
        return this.rawGetPointee && (t = this.rawGetPointee(t)), t;
      },
      destructor(t) {
        var e;
        (e = this.rawDestructor) === null || e === void 0 || e.call(this, t);
      },
      readValueFromPointer: it,
      fromWireType: Nr
    });
  };
  function Tt(t, e, r, n, a, i, s, u, c, h, p) {
    this.name = t, this.registeredClass = e, this.isReference = r, this.isConst = n, this.isSmartPointer = a, this.pointeeType = i, this.sharingPolicy = s, this.rawGetPointee = u, this.rawConstructor = c, this.rawShare = h, this.rawDestructor = p, !a && e.baseClass === void 0 ? n ? (this.toWireType = Br, this.destructorFunction = null) : (this.toWireType = Vr, this.destructorFunction = null) : this.toWireType = Ur;
  }
  var he = (t, e, r) => {
    f.hasOwnProperty(t) || bt("Replacing nonexistent public symbol"), f[t].overloadTable !== void 0 && r !== void 0 ? f[t].overloadTable[r] = e : (f[t] = e, f[t].argCount = r);
  }, N = {}, Gr = (t, e, r) => {
    t = t.replace(/p/g, "i");
    var n = N[t];
    return n(e, ...r);
  }, de = [], w = (t) => {
    var e = de[t];
    return e || (de[t] = e = Fe.get(t)), e;
  }, Xr = function(t, e) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    if (t.includes("j"))
      return Gr(t, e, r);
    var n = w(e), a = n(...r);
    return a;
  }, qr = function(t, e) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    return function() {
      for (var n = arguments.length, a = new Array(n), i = 0; i < n; i++)
        a[i] = arguments[i];
      return Xr(t, e, a, r);
    };
  }, L = function(t, e) {
    t = F(t);
    function r() {
      if (t.includes("j"))
        return qr(t, e);
      var a = w(e);
      return a;
    }
    var n = r();
    return typeof n != "function" && $(`unknown function pointer with signature ${t}: ${e}`), n;
  };
  class Yr extends Error {
  }
  var pe = (t) => {
    var e = Ee(t), r = F(e);
    return z(e), r;
  }, Et = (t, e) => {
    var r = [], n = {};
    function a(i) {
      if (!n[i] && !Z[i]) {
        if (wt[i]) {
          wt[i].forEach(a);
          return;
        }
        r.push(i), n[i] = !0;
      }
    }
    throw e.forEach(a), new Yr(`${t}: ` + r.map(pe).join([", "]));
  }, Zr = (t, e, r, n, a, i, s, u, c, h, p, y, C) => {
    p = F(p), i = L(a, i), u && (u = L(s, u)), h && (h = L(c, h)), C = L(y, C);
    var P = Lr(p);
    le(P, function() {
      Et(`Cannot construct ${p} due to unbound types`, [n]);
    }), Q([t, e, r], n ? [n] : [], (S) => {
      S = S[0];
      var x, O;
      n ? (x = S.registeredClass, O = x.instancePrototype) : O = $t.prototype;
      var E = Ut(p, function() {
        if (Object.getPrototypeOf(this) !== K)
          throw new st(`Use 'new' to construct ${p}`);
        if (R.constructor_body === void 0)
          throw new st(`${p} has no accessible constructor`);
        for (var je = arguments.length, _t = new Array(je), xt = 0; xt < je; xt++)
          _t[xt] = arguments[xt];
        var Be = R.constructor_body[_t.length];
        if (Be === void 0)
          throw new st(`Tried to invoke ctor of ${p} with invalid number of parameters (${_t.length}) - expected (${Object.keys(R.constructor_body).toString()}) parameters instead!`);
        return Be.apply(this, _t);
      }), K = Object.create(O, {
        constructor: {
          value: E
        }
      });
      E.prototype = K;
      var R = new jr(p, E, K, C, x, i, u, h);
      if (R.baseClass) {
        var k, Ot;
        (Ot = (k = R.baseClass).__derivedClasses) !== null && Ot !== void 0 || (k.__derivedClasses = []), R.baseClass.__derivedClasses.push(R);
      }
      var Da = new Tt(p, R, !0, !1, !1), Re = new Tt(p + "*", R, !1, !1, !1), Le = new Tt(p + " const*", R, !1, !0, !1);
      return ue[t] = {
        pointerType: Re,
        constPointerType: Le
      }, he(P, E), [Da, Re, Le];
    });
  }, Ht = (t, e) => {
    for (var r = [], n = 0; n < t; n++)
      r.push(T[e + n * 4 >> 2]);
    return r;
  };
  function Qr(t) {
    for (var e = 1; e < t.length; ++e)
      if (t[e] !== null && t[e].destructorFunction === void 0)
        return !0;
    return !1;
  }
  function kt(t, e, r, n, a, i) {
    var s = e.length;
    s < 2 && $("argTypes array size mismatch! Must at least get return value and 'this' types!");
    var u = e[1] !== null && r !== null, c = Qr(e), h = !e[0].isVoid, p = s - 2, y = new Array(p), C = [], P = [], S = function() {
      P.length = 0;
      var x;
      C.length = u ? 2 : 1, C[0] = a, u && (x = e[1].toWireType(P, this), C[1] = x);
      for (var O = 0; O < p; ++O)
        y[O] = e[O + 2].toWireType(P, O < 0 || arguments.length <= O ? void 0 : arguments[O]), C.push(y[O]);
      var E = n(...C);
      function K(R) {
        if (c)
          Lt(P);
        else
          for (var k = u ? 1 : 2; k < e.length; k++) {
            var Ot = k === 1 ? x : y[k - 2];
            e[k].destructorFunction !== null && e[k].destructorFunction(Ot);
          }
        if (h)
          return e[0].fromWireType(R);
      }
      return K(E);
    };
    return Ut(t, S);
  }
  var Jr = (t, e, r, n, a, i) => {
    var s = Ht(e, r);
    a = L(n, a), Q([], [t], (u) => {
      u = u[0];
      var c = `constructor ${u.name}`;
      if (u.registeredClass.constructor_body === void 0 && (u.registeredClass.constructor_body = []), u.registeredClass.constructor_body[e - 1] !== void 0)
        throw new st(`Cannot register multiple constructors with identical number of parameters (${e - 1}) for class '${u.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
      return u.registeredClass.constructor_body[e - 1] = () => {
        Et(`Cannot construct ${u.name} due to unbound types`, s);
      }, Q([], s, (h) => (h.splice(1, 0, null), u.registeredClass.constructor_body[e - 1] = kt(c, h, null, a, i), [])), [];
    });
  }, ye = (t) => {
    t = t.trim();
    const e = t.indexOf("(");
    return e === -1 ? t : t.slice(0, e);
  }, Kr = (t, e, r, n, a, i, s, u, c, h) => {
    var p = Ht(r, n);
    e = F(e), e = ye(e), i = L(a, i), Q([], [t], (y) => {
      y = y[0];
      var C = `${y.name}.${e}`;
      e.startsWith("@@") && (e = Symbol[e.substring(2)]), u && y.registeredClass.pureVirtualFunctions.push(e);
      function P() {
        Et(`Cannot call ${C} due to unbound types`, p);
      }
      var S = y.registeredClass.instancePrototype, x = S[e];
      return x === void 0 || x.overloadTable === void 0 && x.className !== y.name && x.argCount === r - 2 ? (P.argCount = r - 2, P.className = y.name, S[e] = P) : (ce(S, e, C), S[e].overloadTable[r - 2] = P), Q([], p, (O) => {
        var E = kt(C, O, y, i, s);
        return S[e].overloadTable === void 0 ? (E.argCount = r - 2, S[e] = E) : S[e].overloadTable[r - 2] = E, [];
      }), [];
    });
  }, ve = [], J = [0, 1, , 1, null, 1, !0, 1, !1, 1], Nt = (t) => {
    t > 9 && --J[t + 1] === 0 && (J[t] = void 0, ve.push(t));
  }, B = {
    toValue: (t) => (t || $(`Cannot use deleted val. handle = ${t}`), J[t]),
    toHandle: (t) => {
      switch (t) {
        case void 0:
          return 2;
        case null:
          return 4;
        case !0:
          return 6;
        case !1:
          return 8;
        default: {
          const e = ve.pop() || J.length;
          return J[e] = t, J[e + 1] = 1, e;
        }
      }
    }
  }, me = {
    name: "emscripten::val",
    fromWireType: (t) => {
      var e = B.toValue(t);
      return Nt(t), e;
    },
    toWireType: (t, e) => B.toHandle(e),
    readValueFromPointer: it,
    destructorFunction: null
  }, tn = (t) => j(t, me), en = (t, e) => {
    switch (e) {
      case 4:
        return function(r) {
          return this.fromWireType(Kt[r >> 2]);
        };
      case 8:
        return function(r) {
          return this.fromWireType(te[r >> 3]);
        };
      default:
        throw new TypeError(`invalid float width (${e}): ${t}`);
    }
  }, rn = (t, e, r) => {
    e = F(e), j(t, {
      name: e,
      fromWireType: (n) => n,
      toWireType: (n, a) => a,
      readValueFromPointer: en(e, r),
      destructorFunction: null
    });
  }, nn = (t, e, r, n, a, i, s, u) => {
    var c = Ht(e, r);
    t = F(t), t = ye(t), a = L(n, a), le(t, function() {
      Et(`Cannot call ${t} due to unbound types`, c);
    }, e - 1), Q([], c, (h) => {
      var p = [h[0], null].concat(h.slice(1));
      return he(t, kt(t, p, null, a, i), e - 1), [];
    });
  }, an = (t, e, r) => {
    switch (e) {
      case 1:
        return r ? (n) => Y[n] : (n) => W[n];
      case 2:
        return r ? (n) => dt[n >> 1] : (n) => at[n >> 1];
      case 4:
        return r ? (n) => ot[n >> 2] : (n) => T[n >> 2];
      default:
        throw new TypeError(`invalid integer width (${e}): ${t}`);
    }
  }, on = (t, e, r, n, a) => {
    e = F(e);
    const i = n === 0;
    let s = (c) => c;
    if (i) {
      var u = 32 - 8 * r;
      s = (c) => c << u >>> u, a = s(a);
    }
    j(t, {
      name: e,
      fromWireType: s,
      toWireType: (c, h) => h,
      readValueFromPointer: an(e, r, n !== 0),
      destructorFunction: null
    });
  }, sn = (t, e, r) => {
    var n = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], a = n[e];
    function i(s) {
      var u = T[s >> 2], c = T[s + 4 >> 2];
      return new a(Y.buffer, c, u);
    }
    r = F(r), j(t, {
      name: r,
      fromWireType: i,
      readValueFromPointer: i
    }, {
      ignoreDuplicateRegistrations: !0
    });
  }, un = Object.assign({
    optional: !0
  }, me), cn = (t, e) => {
    j(t, un);
  }, ln = (t, e, r, n) => {
    if (!(n > 0)) return 0;
    for (var a = r, i = r + n - 1, s = 0; s < t.length; ++s) {
      var u = t.codePointAt(s);
      if (u <= 127) {
        if (r >= i) break;
        e[r++] = u;
      } else if (u <= 2047) {
        if (r + 1 >= i) break;
        e[r++] = 192 | u >> 6, e[r++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (r + 2 >= i) break;
        e[r++] = 224 | u >> 12, e[r++] = 128 | u >> 6 & 63, e[r++] = 128 | u & 63;
      } else {
        if (r + 3 >= i) break;
        e[r++] = 240 | u >> 18, e[r++] = 128 | u >> 12 & 63, e[r++] = 128 | u >> 6 & 63, e[r++] = 128 | u & 63, s++;
      }
    }
    return e[r] = 0, r - a;
  }, rt = (t, e, r) => ln(t, W, e, r), ge = (t) => {
    for (var e = 0, r = 0; r < t.length; ++r) {
      var n = t.charCodeAt(r);
      n <= 127 ? e++ : n <= 2047 ? e += 2 : n >= 55296 && n <= 57343 ? (e += 4, ++r) : e += 3;
    }
    return e;
  }, we = globalThis.TextDecoder && new TextDecoder(), be = (t, e, r, n) => {
    var a = e + r;
    if (n) return a;
    for (; t[e] && !(e >= a); ) ++e;
    return e;
  }, $e = function(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = arguments.length > 2 ? arguments[2] : void 0, n = arguments.length > 3 ? arguments[3] : void 0;
    var a = be(t, e, r, n);
    if (a - e > 16 && t.buffer && we)
      return we.decode(t.subarray(e, a));
    for (var i = ""; e < a; ) {
      var s = t[e++];
      if (!(s & 128)) {
        i += String.fromCharCode(s);
        continue;
      }
      var u = t[e++] & 63;
      if ((s & 224) == 192) {
        i += String.fromCharCode((s & 31) << 6 | u);
        continue;
      }
      var c = t[e++] & 63;
      if ((s & 240) == 224 ? s = (s & 15) << 12 | u << 6 | c : s = (s & 7) << 18 | u << 12 | c << 6 | t[e++] & 63, s < 65536)
        i += String.fromCharCode(s);
      else {
        var h = s - 65536;
        i += String.fromCharCode(55296 | h >> 10, 56320 | h & 1023);
      }
    }
    return i;
  }, fn = (t, e, r) => t ? $e(W, t, e, r) : "", hn = (t, e) => {
    e = F(e), j(t, {
      name: e,
      fromWireType(r) {
        var n = T[r >> 2], a = r + 4, i;
        return i = fn(a, n, !0), z(r), i;
      },
      toWireType(r, n) {
        n instanceof ArrayBuffer && (n = new Uint8Array(n));
        var a, i = typeof n == "string";
        i || ArrayBuffer.isView(n) && n.BYTES_PER_ELEMENT == 1 || $("Cannot pass non-string to std::string"), i ? a = ge(n) : a = n.length;
        var s = Xt(4 + a + 1), u = s + 4;
        return T[s >> 2] = a, i ? rt(n, u, a + 1) : W.set(n, u), r !== null && r.push(z, s), s;
      },
      readValueFromPointer: it,
      destructorFunction(r) {
        z(r);
      }
    });
  }, Ce = globalThis.TextDecoder ? new TextDecoder("utf-16le") : void 0, dn = (t, e, r) => {
    var n = t >> 1, a = be(at, n, e / 2, r);
    if (a - n > 16 && Ce) return Ce.decode(at.subarray(n, a));
    for (var i = "", s = n; s < a; ++s) {
      var u = at[s];
      i += String.fromCharCode(u);
    }
    return i;
  }, pn = (t, e, r) => {
    if (r != null || (r = 2147483647), r < 2) return 0;
    r -= 2;
    for (var n = e, a = r < t.length * 2 ? r / 2 : t.length, i = 0; i < a; ++i) {
      var s = t.charCodeAt(i);
      dt[e >> 1] = s, e += 2;
    }
    return dt[e >> 1] = 0, e - n;
  }, yn = (t) => t.length * 2, vn = (t, e, r) => {
    for (var n = "", a = t >> 2, i = 0; !(i >= e / 4); i++) {
      var s = T[a + i];
      if (!s && !r) break;
      n += String.fromCodePoint(s);
    }
    return n;
  }, mn = (t, e, r) => {
    if (r != null || (r = 2147483647), r < 4) return 0;
    for (var n = e, a = n + r - 4, i = 0; i < t.length; ++i) {
      var s = t.codePointAt(i);
      if (s > 65535 && i++, ot[e >> 2] = s, e += 4, e + 4 > a) break;
    }
    return ot[e >> 2] = 0, e - n;
  }, gn = (t) => {
    for (var e = 0, r = 0; r < t.length; ++r) {
      var n = t.codePointAt(r);
      n > 65535 && r++, e += 4;
    }
    return e;
  }, wn = (t, e, r) => {
    r = F(r);
    var n, a, i;
    e === 2 ? (n = dn, a = pn, i = yn) : (n = vn, a = mn, i = gn), j(t, {
      name: r,
      fromWireType: (s) => {
        var u = T[s >> 2], c = n(s + 4, u * e, !0);
        return z(s), c;
      },
      toWireType: (s, u) => {
        typeof u != "string" && $(`Cannot pass non-string to C++ string type ${r}`);
        var c = i(u), h = Xt(4 + c + e);
        return T[h >> 2] = c / e, a(u, h + 4, c + e), s !== null && s.push(z, h), h;
      },
      readValueFromPointer: it,
      destructorFunction(s) {
        z(s);
      }
    });
  }, bn = (t, e, r, n, a, i) => {
    gt[t] = {
      name: F(e),
      rawConstructor: L(r, n),
      rawDestructor: L(a, i),
      fields: []
    };
  }, $n = (t, e, r, n, a, i, s, u, c, h) => {
    gt[t].fields.push({
      fieldName: F(e),
      getterReturnType: r,
      getter: L(n, a),
      getterContext: i,
      setterArgumentType: s,
      setter: L(u, c),
      setterContext: h
    });
  }, Cn = (t, e) => {
    e = F(e), j(t, {
      isVoid: !0,
      name: e,
      fromWireType: () => {
      },
      toWireType: (r, n) => {
      }
    });
  }, zt = [], Tn = (t) => {
    var e = zt.length;
    return zt.push(t), e;
  }, En = (t, e) => {
    var r = Z[t];
    return r === void 0 && $(`${e} has unknown type ${pe(t)}`), r;
  }, Pn = (t, e) => {
    for (var r = new Array(t), n = 0; n < t; ++n)
      r[n] = En(T[e + n * 4 >> 2], `parameter ${n}`);
    return r;
  }, On = (t, e, r) => {
    var n = [], a = t(n, r);
    return n.length && (T[e >> 2] = B.toHandle(n)), a;
  }, _n = {}, Te = (t) => {
    var e = _n[t];
    return e === void 0 ? F(t) : e;
  }, xn = (t, e, r) => {
    var n = 8, [a, ...i] = Pn(t, e), s = a.toWireType.bind(a), u = i.map((y) => y.readValueFromPointer.bind(y));
    t--;
    var c = new Array(t), h = (y, C, P, S) => {
      for (var x = 0, O = 0; O < t; ++O)
        c[O] = u[O](S + x), x += n;
      var E;
      switch (r) {
        case 0:
          E = B.toValue(y).apply(null, c);
          break;
        case 2:
          E = Reflect.construct(B.toValue(y), c);
          break;
        case 3:
          E = c[0];
          break;
        case 1:
          E = B.toValue(y)[Te(C)](...c);
          break;
      }
      return On(s, P, E);
    }, p = `methodCaller<(${i.map((y) => y.name)}) => ${a.name}>`;
    return Tn(Ut(p, h));
  }, Sn = (t) => t ? (t = Te(t), B.toHandle(globalThis[t])) : B.toHandle(globalThis), In = (t) => {
    t > 9 && (J[t + 1] += 1);
  }, Dn = (t, e, r, n, a) => zt[t](e, r, n, a), Mn = (t) => {
    var e = B.toValue(t);
    Lt(e), Nt(t);
  }, An = (t, e, r, n) => {
    var a = (/* @__PURE__ */ new Date()).getFullYear(), i = new Date(a, 0, 1), s = new Date(a, 6, 1), u = i.getTimezoneOffset(), c = s.getTimezoneOffset(), h = Math.max(u, c);
    T[t >> 2] = h * 60, ot[e >> 2] = +(u != c);
    var p = (P) => {
      var S = P >= 0 ? "-" : "+", x = Math.abs(P), O = String(Math.floor(x / 60)).padStart(2, "0"), E = String(x % 60).padStart(2, "0");
      return `UTC${S}${O}${E}`;
    }, y = p(u), C = p(c);
    c < u ? (rt(y, r, 17), rt(C, n, 17)) : (rt(y, n, 17), rt(C, r, 17));
  }, Fn = () => 2147483648, Rn = (t, e) => Math.ceil(t / e) * e, Ln = (t) => {
    var e = Pt.buffer.byteLength, r = (t - e + 65535) / 65536 | 0;
    try {
      return Pt.grow(r), re(), 1;
    } catch {
    }
  }, jn = (t) => {
    var e = W.length;
    t >>>= 0;
    var r = Fn();
    if (t > r)
      return !1;
    for (var n = 1; n <= 4; n *= 2) {
      var a = e * (1 + 0.2 / n);
      a = Math.min(a, t + 100663296);
      var i = Math.min(r, Rn(Math.max(t, a), 65536)), s = Ln(i);
      if (s)
        return !0;
    }
    return !1;
  }, Gt = {}, Bn = () => _ || "./this.program", ct = () => {
    if (!ct.strings) {
      var t = (typeof navigator == "object" && navigator.language || "C").replace("-", "_") + ".UTF-8", e = {
        USER: "web_user",
        LOGNAME: "web_user",
        PATH: "/",
        PWD: "/",
        HOME: "/home/web_user",
        LANG: t,
        _: Bn()
      };
      for (var r in Gt)
        Gt[r] === void 0 ? delete e[r] : e[r] = Gt[r];
      var n = [];
      for (var r in e)
        n.push(`${r}=${e[r]}`);
      ct.strings = n;
    }
    return ct.strings;
  }, Un = (t, e) => {
    var r = 0, n = 0;
    for (var a of ct()) {
      var i = e + r;
      T[t + n >> 2] = i, r += rt(a, i, 1 / 0) + 1, n += 4;
    }
    return 0;
  }, Vn = (t, e) => {
    var r = ct();
    T[t >> 2] = r.length;
    var n = 0;
    for (var a of r)
      n += ge(a) + 1;
    return T[e >> 2] = n, 0;
  }, Wn = (t) => 52;
  function Hn(t, e, r, n, a) {
    return 70;
  }
  var kn = [null, [], []], Nn = (t, e) => {
    var r = kn[t];
    e === 0 || e === 10 ? ((t === 1 ? nt : V)($e(r)), r.length = 0) : r.push(e);
  }, zn = (t, e, r, n) => {
    for (var a = 0, i = 0; i < r; i++) {
      var s = T[e >> 2], u = T[e + 4 >> 2];
      e += 8;
      for (var c = 0; c < u; c++)
        Nn(t, W[s + c]);
      a += u;
    }
    return T[n >> 2] = a, 0;
  }, Gn = (t) => t;
  if (Ar(), zr(), f.noExitRuntime && f.noExitRuntime, f.print && (nt = f.print), f.printErr && (V = f.printErr), f.wasmBinary && (q = f.wasmBinary), f.arguments && f.arguments, f.thisProgram && (_ = f.thisProgram), f.preInit)
    for (typeof f.preInit == "function" && (f.preInit = [f.preInit]); f.preInit.length > 0; )
      f.preInit.shift()();
  var Ee, z, Xt, Pe, v, Oe, _e, xe, Se, Ie, De, Me, Ae, Pt, Fe;
  function Xn(t) {
    Ee = t.ya, z = f._free = t.za, Xt = f._malloc = t.Ba, Pe = t.Ca, v = t.Da, Oe = t.Ea, _e = t.Fa, xe = t.Ga, Se = t.Ha, Ie = t.Ia, De = t.Ja, N.viijii = t.Ka, Me = N.iiijj = t.La, N.jiji = t.Ma, Ae = N.jiiii = t.Na, N.iiiiij = t.Oa, N.iiiiijj = t.Pa, N.iiiiiijj = t.Qa, Pt = t.wa, Fe = t.Aa;
  }
  var qn = {
    s: vr,
    w: mr,
    a: gr,
    j: wr,
    m: br,
    Q: $r,
    p: Cr,
    U: Tr,
    d: Er,
    ca: Pr,
    ta: _r,
    ba: xr,
    oa: Ir,
    ra: Zr,
    qa: Jr,
    H: Kr,
    ma: tn,
    X: rn,
    Y: nn,
    x: on,
    t: sn,
    sa: cn,
    na: hn,
    R: wn,
    I: bn,
    ua: $n,
    pa: Cn,
    N: xn,
    va: Nt,
    D: Sn,
    S: In,
    M: Dn,
    ia: Mn,
    da: An,
    ga: jn,
    ea: Un,
    fa: Vn,
    ha: Wn,
    $: Hn,
    V: zn,
    K: ma,
    C: ba,
    Z: ea,
    T: Oa,
    r: da,
    b: Kn,
    E: va,
    ka: Ca,
    c: ra,
    ja: Ta,
    h: ta,
    i: oa,
    q: ca,
    P: ya,
    v: fa,
    F: ha,
    L: pa,
    z: $a,
    J: _a,
    aa: xa,
    _: Sa,
    f: na,
    l: Yn,
    e: Jn,
    g: Qn,
    O: Pa,
    k: Zn,
    la: ga,
    o: la,
    B: ia,
    u: wa,
    W: ua,
    A: Ea,
    n: aa,
    G: sa,
    y: Gn
  };
  function Yn(t, e) {
    var r = g();
    try {
      w(t)(e);
    } catch (n) {
      if (m(r), n !== n + 0) throw n;
      v(1, 0);
    }
  }
  function Zn(t, e, r, n, a) {
    var i = g();
    try {
      w(t)(e, r, n, a);
    } catch (s) {
      if (m(i), s !== s + 0) throw s;
      v(1, 0);
    }
  }
  function Qn(t, e, r, n) {
    var a = g();
    try {
      w(t)(e, r, n);
    } catch (i) {
      if (m(a), i !== i + 0) throw i;
      v(1, 0);
    }
  }
  function Jn(t, e, r) {
    var n = g();
    try {
      w(t)(e, r);
    } catch (a) {
      if (m(n), a !== a + 0) throw a;
      v(1, 0);
    }
  }
  function Kn(t, e) {
    var r = g();
    try {
      return w(t)(e);
    } catch (n) {
      if (m(r), n !== n + 0) throw n;
      v(1, 0);
    }
  }
  function ta(t, e, r, n) {
    var a = g();
    try {
      return w(t)(e, r, n);
    } catch (i) {
      if (m(a), i !== i + 0) throw i;
      v(1, 0);
    }
  }
  function ea(t, e, r, n, a, i) {
    var s = g();
    try {
      return w(t)(e, r, n, a, i);
    } catch (u) {
      if (m(s), u !== u + 0) throw u;
      v(1, 0);
    }
  }
  function ra(t, e, r) {
    var n = g();
    try {
      return w(t)(e, r);
    } catch (a) {
      if (m(n), a !== a + 0) throw a;
      v(1, 0);
    }
  }
  function na(t) {
    var e = g();
    try {
      w(t)();
    } catch (r) {
      if (m(e), r !== r + 0) throw r;
      v(1, 0);
    }
  }
  function aa(t, e, r, n, a, i, s, u, c, h, p) {
    var y = g();
    try {
      w(t)(e, r, n, a, i, s, u, c, h, p);
    } catch (C) {
      if (m(y), C !== C + 0) throw C;
      v(1, 0);
    }
  }
  function oa(t, e, r, n, a) {
    var i = g();
    try {
      return w(t)(e, r, n, a);
    } catch (s) {
      if (m(i), s !== s + 0) throw s;
      v(1, 0);
    }
  }
  function ia(t, e, r, n, a, i, s) {
    var u = g();
    try {
      w(t)(e, r, n, a, i, s);
    } catch (c) {
      if (m(u), c !== c + 0) throw c;
      v(1, 0);
    }
  }
  function sa(t, e, r, n, a, i, s, u, c, h, p, y, C, P, S, x) {
    var O = g();
    try {
      w(t)(e, r, n, a, i, s, u, c, h, p, y, C, P, S, x);
    } catch (E) {
      if (m(O), E !== E + 0) throw E;
      v(1, 0);
    }
  }
  function ua(t, e, r, n, a, i, s, u, c) {
    var h = g();
    try {
      w(t)(e, r, n, a, i, s, u, c);
    } catch (p) {
      if (m(h), p !== p + 0) throw p;
      v(1, 0);
    }
  }
  function ca(t, e, r, n, a, i) {
    var s = g();
    try {
      return w(t)(e, r, n, a, i);
    } catch (u) {
      if (m(s), u !== u + 0) throw u;
      v(1, 0);
    }
  }
  function la(t, e, r, n, a, i) {
    var s = g();
    try {
      w(t)(e, r, n, a, i);
    } catch (u) {
      if (m(s), u !== u + 0) throw u;
      v(1, 0);
    }
  }
  function fa(t, e, r, n, a, i, s) {
    var u = g();
    try {
      return w(t)(e, r, n, a, i, s);
    } catch (c) {
      if (m(u), c !== c + 0) throw c;
      v(1, 0);
    }
  }
  function ha(t, e, r, n, a, i, s, u) {
    var c = g();
    try {
      return w(t)(e, r, n, a, i, s, u);
    } catch (h) {
      if (m(c), h !== h + 0) throw h;
      v(1, 0);
    }
  }
  function da(t) {
    var e = g();
    try {
      return w(t)();
    } catch (r) {
      if (m(e), r !== r + 0) throw r;
      v(1, 0);
    }
  }
  function pa(t, e, r, n, a, i, s, u, c) {
    var h = g();
    try {
      return w(t)(e, r, n, a, i, s, u, c);
    } catch (p) {
      if (m(h), p !== p + 0) throw p;
      v(1, 0);
    }
  }
  function ya(t, e, r, n, a, i, s) {
    var u = g();
    try {
      return w(t)(e, r, n, a, i, s);
    } catch (c) {
      if (m(u), c !== c + 0) throw c;
      v(1, 0);
    }
  }
  function va(t, e, r, n) {
    var a = g();
    try {
      return w(t)(e, r, n);
    } catch (i) {
      if (m(a), i !== i + 0) throw i;
      v(1, 0);
    }
  }
  function ma(t, e, r, n) {
    var a = g();
    try {
      return w(t)(e, r, n);
    } catch (i) {
      if (m(a), i !== i + 0) throw i;
      v(1, 0);
    }
  }
  function ga(t, e, r, n, a, i, s, u) {
    var c = g();
    try {
      w(t)(e, r, n, a, i, s, u);
    } catch (h) {
      if (m(c), h !== h + 0) throw h;
      v(1, 0);
    }
  }
  function wa(t, e, r, n, a, i, s, u) {
    var c = g();
    try {
      w(t)(e, r, n, a, i, s, u);
    } catch (h) {
      if (m(c), h !== h + 0) throw h;
      v(1, 0);
    }
  }
  function ba(t, e, r, n, a, i) {
    var s = g();
    try {
      return w(t)(e, r, n, a, i);
    } catch (u) {
      if (m(s), u !== u + 0) throw u;
      v(1, 0);
    }
  }
  function $a(t, e, r, n, a, i, s, u, c, h) {
    var p = g();
    try {
      return w(t)(e, r, n, a, i, s, u, c, h);
    } catch (y) {
      if (m(p), y !== y + 0) throw y;
      v(1, 0);
    }
  }
  function Ca(t, e, r) {
    var n = g();
    try {
      return w(t)(e, r);
    } catch (a) {
      if (m(n), a !== a + 0) throw a;
      v(1, 0);
    }
  }
  function Ta(t, e, r, n, a) {
    var i = g();
    try {
      return w(t)(e, r, n, a);
    } catch (s) {
      if (m(i), s !== s + 0) throw s;
      v(1, 0);
    }
  }
  function Ea(t, e, r, n, a, i, s, u, c, h) {
    var p = g();
    try {
      w(t)(e, r, n, a, i, s, u, c, h);
    } catch (y) {
      if (m(p), y !== y + 0) throw y;
      v(1, 0);
    }
  }
  function Pa(t, e, r, n, a, i, s) {
    var u = g();
    try {
      w(t)(e, r, n, a, i, s);
    } catch (c) {
      if (m(u), c !== c + 0) throw c;
      v(1, 0);
    }
  }
  function Oa(t, e, r, n) {
    var a = g();
    try {
      return w(t)(e, r, n);
    } catch (i) {
      if (m(a), i !== i + 0) throw i;
      v(1, 0);
    }
  }
  function _a(t, e, r, n, a, i, s, u, c, h, p, y) {
    var C = g();
    try {
      return w(t)(e, r, n, a, i, s, u, c, h, p, y);
    } catch (P) {
      if (m(C), P !== P + 0) throw P;
      v(1, 0);
    }
  }
  function xa(t, e, r, n, a, i, s) {
    var u = g();
    try {
      return Me(t, e, r, n, a, i, s);
    } catch (c) {
      if (m(u), c !== c + 0) throw c;
      v(1, 0);
    }
  }
  function Sa(t, e, r, n, a) {
    var i = g();
    try {
      return Ae(t, e, r, n, a);
    } catch (s) {
      if (m(i), s !== s + 0) throw s;
      v(1, 0);
    }
  }
  function Ia() {
    ar();
    function t() {
      var e, r;
      f.calledRun = !0, !ht && (or(), (e = Qt) === null || e === void 0 || e(f), (r = f.onRuntimeInitialized) === null || r === void 0 || r.call(f), ir());
    }
    f.setStatus ? (f.setStatus("Running..."), setTimeout(() => {
      setTimeout(() => f.setStatus(""), 1), t();
    }, 1)) : t();
  }
  var lt;
  return lt = await dr(), Ia(), ee ? l = f : l = new Promise((t, e) => {
    Qt = t, Jt = e;
  }), l;
}
function qe(o) {
  return Xe(Zt, o);
}
function mo() {
  return qa(Zt);
}
function go(o) {
  qe({
    overrides: o,
    equalityFn: Object.is,
    fireImmediately: !1
  });
}
async function Za(o, l) {
  return Ya(Zt, o, l);
}
const wo = "85d46f55d7c86a4d09bb04273367408b19c324f582d040d018aecb25a9a82942", Ye = [
  ["aztec", "Aztec"],
  ["code_128", "Code128"],
  ["code_39", "Code39"],
  ["code_93", "Code93"],
  ["codabar", "Codabar"],
  ["databar", "DataBar"],
  ["databar_expanded", "DataBarExpanded"],
  ["databar_limited", "DataBarLimited"],
  ["data_matrix", "DataMatrix"],
  ["dx_film_edge", "DXFilmEdge"],
  ["ean_13", "EAN-13"],
  ["ean_8", "EAN-8"],
  ["itf", "ITF"],
  ["maxi_code", "MaxiCode"],
  ["micro_qr_code", "MicroQRCode"],
  ["pdf417", "PDF417"],
  ["qr_code", "QRCode"],
  ["rm_qr_code", "rMQRCode"],
  ["upc_a", "UPC-A"],
  ["upc_e", "UPC-E"],
  ["linear_codes", "Linear-Codes"],
  ["matrix_codes", "Matrix-Codes"],
  ["any", "Any"]
], Qa = [...Ye, ["unknown"]].map((o) => o[0]), Yt = new Map(
  Ye
);
function Ja(o) {
  for (const [l, d] of Yt)
    if (o === d)
      return l;
  return "unknown";
}
function Ka(o) {
  if (Ze(o))
    return {
      width: o.naturalWidth,
      height: o.naturalHeight
    };
  if (Qe(o))
    return {
      width: o.width.baseVal.value,
      height: o.height.baseVal.value
    };
  if (Je(o))
    return {
      width: o.videoWidth,
      height: o.videoHeight
    };
  if (tr(o))
    return {
      width: o.width,
      height: o.height
    };
  if (rr(o))
    return {
      width: o.displayWidth,
      height: o.displayHeight
    };
  if (Ke(o))
    return {
      width: o.width,
      height: o.height
    };
  if (er(o))
    return {
      width: o.width,
      height: o.height
    };
  throw new TypeError(
    "The provided value is not of type '(Blob or HTMLCanvasElement or HTMLImageElement or HTMLVideoElement or ImageBitmap or ImageData or OffscreenCanvas or SVGImageElement or VideoFrame)'."
  );
}
function Ze(o) {
  var l, d;
  try {
    return o instanceof ((d = (l = o == null ? void 0 : o.ownerDocument) == null ? void 0 : l.defaultView) == null ? void 0 : d.HTMLImageElement);
  } catch {
    return !1;
  }
}
function Qe(o) {
  var l, d;
  try {
    return o instanceof ((d = (l = o == null ? void 0 : o.ownerDocument) == null ? void 0 : l.defaultView) == null ? void 0 : d.SVGImageElement);
  } catch {
    return !1;
  }
}
function Je(o) {
  var l, d;
  try {
    return o instanceof ((d = (l = o == null ? void 0 : o.ownerDocument) == null ? void 0 : l.defaultView) == null ? void 0 : d.HTMLVideoElement);
  } catch {
    return !1;
  }
}
function Ke(o) {
  var l, d;
  try {
    return o instanceof ((d = (l = o == null ? void 0 : o.ownerDocument) == null ? void 0 : l.defaultView) == null ? void 0 : d.HTMLCanvasElement);
  } catch {
    return !1;
  }
}
function tr(o) {
  try {
    return o instanceof ImageBitmap || Object.prototype.toString.call(o) === "[object ImageBitmap]";
  } catch {
    return !1;
  }
}
function er(o) {
  try {
    return o instanceof OffscreenCanvas || Object.prototype.toString.call(o) === "[object OffscreenCanvas]";
  } catch {
    return !1;
  }
}
function rr(o) {
  try {
    return o instanceof VideoFrame || Object.prototype.toString.call(o) === "[object VideoFrame]";
  } catch {
    return !1;
  }
}
function to(o) {
  try {
    return o instanceof Blob || Object.prototype.toString.call(o) === "[object Blob]";
  } catch {
    return !1;
  }
}
function eo(o) {
  try {
    return o instanceof ImageData || Object.prototype.toString.call(o) === "[object ImageData]";
  } catch {
    return !1;
  }
}
function ro(o, l) {
  try {
    const d = new OffscreenCanvas(o, l);
    if (d.getContext("2d") instanceof OffscreenCanvasRenderingContext2D)
      return d;
    throw void 0;
  } catch {
    const d = document.createElement("canvas");
    return d.width = o, d.height = l, d;
  }
}
async function nr(o) {
  if (Ze(o) && !await io(o))
    throw new DOMException(
      "Failed to load or decode HTMLImageElement.",
      "InvalidStateError"
    );
  if (Qe(o) && !await so(o))
    throw new DOMException(
      "Failed to load or decode SVGImageElement.",
      "InvalidStateError"
    );
  if (rr(o) && uo(o))
    throw new DOMException("VideoFrame is closed.", "InvalidStateError");
  if (Je(o) && (o.readyState === 0 || o.readyState === 1))
    throw new DOMException("Invalid element or state.", "InvalidStateError");
  if (tr(o) && lo(o))
    throw new DOMException(
      "The image source is detached.",
      "InvalidStateError"
    );
  const { width: l, height: d } = Ka(o);
  if (l === 0 || d === 0)
    return null;
  const f = ro(l, d).getContext("2d");
  f.drawImage(o, 0, 0);
  try {
    return f.getImageData(0, 0, l, d);
  } catch {
    throw new DOMException("Source would taint origin.", "SecurityError");
  }
}
async function no(o) {
  let l;
  try {
    l = await createImageBitmap(o);
  } catch {
    try {
      if (globalThis.Image) {
        l = new Image();
        let f = "";
        try {
          f = URL.createObjectURL(o), l.src = f, await l.decode();
        } finally {
          URL.revokeObjectURL(f);
        }
      } else
        return o;
    } catch {
      throw new DOMException(
        "Failed to load or decode Blob.",
        "InvalidStateError"
      );
    }
  }
  return await nr(l);
}
function ao(o) {
  const { width: l, height: d } = o;
  if (l === 0 || d === 0)
    return null;
  const b = o.getContext("2d");
  try {
    return b.getImageData(0, 0, l, d);
  } catch {
    throw new DOMException("Source would taint origin.", "SecurityError");
  }
}
async function oo(o) {
  if (to(o))
    return await no(o);
  if (eo(o)) {
    if (co(o))
      throw new DOMException(
        "The image data has been detached.",
        "InvalidStateError"
      );
    return o;
  }
  return Ke(o) || er(o) ? ao(o) : await nr(o);
}
async function io(o) {
  try {
    return await o.decode(), !0;
  } catch {
    return !1;
  }
}
async function so(o) {
  var l;
  try {
    return await ((l = o.decode) == null ? void 0 : l.call(o)), !0;
  } catch {
    return !1;
  }
}
function uo(o) {
  return o.format === null;
}
function co(o) {
  return o.data.buffer.byteLength === 0;
}
function lo(o) {
  return o.width === 0 && o.height === 0;
}
function Ge(o, l) {
  return fo(o) ? new DOMException(`${l}: ${o.message}`, o.name) : ho(o) ? new o.constructor(`${l}: ${o.message}`) : new Error(`${l}: ${o}`);
}
function fo(o) {
  return o instanceof DOMException || Object.prototype.toString.call(o) === "[object DOMException]";
}
function ho(o) {
  return o instanceof Error || Object.prototype.toString.call(o) === "[object Error]";
}
var ft;
class bo {
  constructor(l = {}) {
    He(this, ft);
    var d;
    try {
      const b = (d = l == null ? void 0 : l.formats) == null ? void 0 : d.filter(
        (f) => f !== "unknown"
      );
      if ((b == null ? void 0 : b.length) === 0)
        throw new TypeError("Hint option provided, but is empty.");
      for (const f of b != null ? b : [])
        if (!Yt.has(f))
          throw new TypeError(
            `Failed to read the 'formats' property from 'BarcodeDetectorOptions': The provided value '${f}' is not a valid enum value of type BarcodeFormat.`
          );
      ke(this, ft, b != null ? b : []), qe({ fireImmediately: !0 }).catch(() => {
      });
    } catch (b) {
      throw Ge(
        b,
        "Failed to construct 'BarcodeDetector'"
      );
    }
  }
  static async getSupportedFormats() {
    return Qa.filter((l) => l !== "unknown");
  }
  async detect(l) {
    try {
      const d = await oo(l);
      if (d === null)
        return [];
      let b;
      const f = {
        tryCode39ExtendedMode: !1,
        textMode: "Plain",
        formats: We(this, ft).map((I) => Yt.get(I))
      };
      try {
        b = await Za(d, f);
      } catch (I) {
        throw console.error(I), new DOMException(
          "Barcode detection service unavailable.",
          "NotSupportedError"
        );
      }
      return b.map((I) => {
        const {
          topLeft: { x: D, y: M },
          topRight: { x: _, y: A },
          bottomLeft: { x: U, y: G },
          bottomRight: { x: tt, y: X }
        } = I.position, nt = Math.min(D, _, U, tt), V = Math.min(M, A, G, X), q = Math.max(D, _, U, tt), ht = Math.max(M, A, G, X);
        return {
          boundingBox: new DOMRectReadOnly(
            nt,
            V,
            q - nt,
            ht - V
          ),
          rawValue: I.text,
          format: Ja(I.format),
          cornerPoints: [
            {
              x: D,
              y: M
            },
            {
              x: _,
              y: A
            },
            {
              x: tt,
              y: X
            },
            {
              x: U,
              y: G
            }
          ]
        };
      });
    } catch (d) {
      throw Ge(
        d,
        "Failed to execute 'detect' on 'BarcodeDetector'"
      );
    }
  }
}
ft = new WeakMap();
export {
  bo as BarcodeDetector,
  vo as ZXING_CPP_COMMIT,
  wo as ZXING_WASM_SHA256,
  yo as ZXING_WASM_VERSION,
  qe as prepareZXingModule,
  mo as purgeZXingModule,
  go as setZXingModuleOverrides
};
